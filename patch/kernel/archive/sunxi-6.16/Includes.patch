From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: John Doe <john.doe@somewhere.on.planet>
Date: Wed, 9 Jul 2025 17:42:22 +0200
Subject: Patching kernel sun55iw3 files include/boot_param.h
 include/dt-bindings/clock/sun55i-a523-ccu.h
 include/dt-bindings/clock/sun55iw3-mcu-ccu.h
 include/dt-bindings/display/lcd_command.h
 include/dt-bindings/display/sunxi-lcd.h
 include/dt-bindings/power/a523-power.h
 include/dt-bindings/reset/sun55i-a523-ccu.h
 include/dt-bindings/reset/sun55iw3-mcu-ccu.h
 include/dt-bindings/spi/sunxi-spi.h include/errcode/sunxi-err-audio.h
 include/errcode/sunxi-err.h include/sunxi-dma.h include/sunxi-gpio.h
 include/sunxi-inno.h include/sunxi-iommu.h include/sunxi-log.h
 include/sunxi-sid.h include/video/drv_hdmi.h include/video/sunxi_drm.h
 include/video/sunxi_metadata.h

Signed-off-by: John Doe <john.doe@somewhere.on.planet>
---
 include/boot_param.h                         | 111 +++
 include/dt-bindings/clock/sun55i-a523-ccu.h  |   5 +
 include/dt-bindings/clock/sun55iw3-mcu-ccu.h |  58 ++
 include/dt-bindings/display/lcd_command.h    |  48 ++
 include/dt-bindings/display/sunxi-lcd.h      |  25 +
 include/dt-bindings/power/a523-power.h       |  18 +
 include/dt-bindings/reset/sun55i-a523-ccu.h  |   1 +
 include/dt-bindings/reset/sun55iw3-mcu-ccu.h |  31 +
 include/dt-bindings/spi/sunxi-spi.h          |  18 +
 include/errcode/sunxi-err-audio.h            |  61 ++
 include/errcode/sunxi-err.h                  | 199 +++++
 include/sunxi-dma.h                          |  33 +
 include/sunxi-gpio.h                         | 188 +++++
 include/sunxi-inno.h                         |  10 +
 include/sunxi-iommu.h                        |  52 ++
 include/sunxi-log.h                          | 176 +++++
 include/sunxi-sid.h                          | 199 +++++
 include/video/drv_hdmi.h                     |  60 ++
 include/video/sunxi_drm.h                    | 376 ++++++++++
 include/video/sunxi_metadata.h               | 351 +++++++++
 20 files changed, 2020 insertions(+)

diff --git a/include/boot_param.h b/include/boot_param.h
new file mode 100644
index 000000000000..5d77eac58941
--- /dev/null
+++ b/include/boot_param.h
@@ -0,0 +1,111 @@
+/* SPDX-License-Identifier: GPL-2.0-or-later */
+/* Copyright(c) 2020 - 2023 Allwinner Technology Co.,Ltd. All rights reserved. */
+/*
+ * include/boot_param.h
+ *
+ * Copyright (c) 2021-2025 Allwinnertech Co., Ltd.
+ * Author: lujianliang <lujianliang@allwinnertech.com>
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+#ifndef __BOOT_PARAM_H
+#define __BOOT_PARAM_H
+
+#include <linux/mtd/spi-nor.h>
+
+#define BOOT_PARAM_MAGIC		"bootpara"
+#define BOOT_PARAM_SIZE			4096
+#define CHECK_SUM			0x5F0A6C39
+#define CONFIG_SPINOR_UBOOT_OFFSET	128 /* sectors */
+
+struct sunxi_boot_parameter_header {
+	u8 magic[8]; //bootpara
+	u32 version; // describe the region version
+	u32 check_sum;
+	u32 length;
+	u8 reserved[12];
+};
+
+//---total len is 4K
+struct sunxi_boot_param_region {
+	struct sunxi_boot_parameter_header header;//32
+	char sdmmc_info[256];
+	char nand_info[256];
+	char spiflash_info[256];
+	char ddr_info[512];
+	u8 reserved[2784];// = 4096 - sdmmc_size - nand_size - spi_size - ddr_size - 32
+};
+
+#define SPINOR_BOOT_PARAM_MAGIC		"NORPARAM"
+typedef struct {
+	u8			magic[8];
+	__s32			readcmd;
+	__s32			read_mode;
+	__s32			write_mode;
+	__s32			flash_size;
+	__s32			addr4b_opcodes;
+	__s32			erase_size;
+	__s32			delay_cycle;/*When the frequency is greater than 60MHZ configured as 1;less than 24MHZ configured as 2;greater 24MHZ and less 60HZ as 3*/
+	__s32			lock_flag;
+	__s32			frequency;
+	unsigned int		sample_delay;
+	unsigned int		sample_mode;
+	enum spi_nor_protocol	read_proto;
+	enum spi_nor_protocol	write_proto;
+	u8			read_dummy;
+} boot_spinor_info_t;
+
+/******************************************************************************/
+/*                              head of Boot0                                 */
+/******************************************************************************/
+#define BOOT0_MAGIC                     "eGON.BT0"
+typedef struct _normal_gpio_cfg {
+	unsigned char port;
+	unsigned char port_num;
+	char mul_sel;
+	char pull;
+	char drv_level;
+	char data;
+	unsigned char reserved[2];
+} normal_gpio_cfg;
+
+typedef struct _boot0_private_head_t {
+	unsigned int prvt_head_size;
+	char prvt_head_vsn[4];        /* the version of boot0_private_head_t */
+	unsigned int dram_para[32];   /* Original values is arbitrary */
+	int uart_port;
+	normal_gpio_cfg uart_ctrl[2];
+	int enable_jtag;              /* 1 : enable,  0 : disable */
+	normal_gpio_cfg jtag_gpio[5];
+	normal_gpio_cfg storage_gpio[32];
+	char storage_data[512 - sizeof(normal_gpio_cfg) * 32];
+}
+boot0_private_head_t;
+
+typedef struct standard_Boot_file_head {
+	unsigned int jump_instruction;  /* one intruction jumping to real code */
+	unsigned char magic[8];         /* ="eGON.BT0" or "eGON.BT1",  not C-style string */
+	unsigned int check_sum;         /* generated by PC */
+	unsigned int length;            /* generated by PC */
+	unsigned int pub_head_size;     /* size of boot_file_head_t */
+	unsigned char pub_head_vsn[4];  /* version of boot_file_head_t */
+	unsigned char file_head_vsn[4]; /* version of boot0_file_head_t or boot1_file_head_t */
+	unsigned char Boot_vsn[4];      /* Boot version */
+	unsigned char eGON_vsn[4];      /* eGON version */
+	unsigned char platform[8];      /* platform information */
+} standard_boot_file_head_t;
+
+typedef struct _boot0_file_head_t {
+	standard_boot_file_head_t boot_head;
+	boot0_private_head_t prvt_head;
+} boot0_file_head_t;
+
+#endif
diff --git a/include/dt-bindings/clock/sun55i-a523-ccu.h b/include/dt-bindings/clock/sun55i-a523-ccu.h
index c8259ac5ada7..bec8865abf2c 100644
--- a/include/dt-bindings/clock/sun55i-a523-ccu.h
+++ b/include/dt-bindings/clock/sun55i-a523-ccu.h
@@ -183,7 +183,12 @@
 #define CLK_FANOUT_27M		174
 #define CLK_FANOUT_PCLK		175
 #define CLK_FANOUT0		176
 #define CLK_FANOUT1		177
 #define CLK_FANOUT2		178
+#define CLK_NPU			179
+#define CLK_USB3_MBUS_GATE	180
+#define CLK_USB3_REF		181
+#define CLK_USB2_REF		182
+#define CLK_USB3_SUSPEND	183
 
 #endif /* _DT_BINDINGS_CLK_SUN55I_A523_CCU_H_ */
diff --git a/include/dt-bindings/clock/sun55iw3-mcu-ccu.h b/include/dt-bindings/clock/sun55iw3-mcu-ccu.h
new file mode 100644
index 000000000000..130ec207d24b
--- /dev/null
+++ b/include/dt-bindings/clock/sun55iw3-mcu-ccu.h
@@ -0,0 +1,58 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/* Copyright(c) 2020 - 2023 Allwinner Technology Co.,Ltd. All rights reserved. */
+/*
+ * Copyright (c) 2022 rengaomin@allwinnertech.com
+ */
+
+#ifndef _DT_BINDINGS_CLK_SUN55IW3_MCU_CCU_H_
+#define _DT_BINDINGS_CLK_SUN55IW3_MCU_CCU_H_
+
+#define CLK_PLL_MCU_AUDIO1	0
+#define CLK_PLL_MCU_AUDIO1_DIV2	1
+#define CLK_PLL_MCU_AUDIO1_DIV5	2
+#define CLK_PLL_MCU_AUDIO_OUT	3
+#define CLK_DSP_DSP		4
+#define CLK_MCU_I2S0		5
+#define CLK_MCU_I2S1		6
+#define CLK_MCU_I2S2		7
+#define CLK_MCU_I2S3		8
+#define CLK_MCU_I2S3_ASRC	9
+#define CLK_BUS_MCU_I2S0	10
+#define CLK_BUS_MCU_I2S1	11
+#define CLK_BUS_MCU_I2S2	12
+#define CLK_BUS_MCU_I2S3	13
+#define CLK_MCU_OWA_TX		14
+#define CLK_MCU_OWA_RX		15
+#define CLK_BUS_MCU_OWA		16
+#define CLK_MCU_DMIC		17
+#define CLK_BUS_MCU_DMIC	18
+#define CLK_MCU_AUDIO_CODEC_DAC	19
+#define CLK_MCU_AUDIO_CODEC_ADC	20
+#define CLK_BUS_MCU_AUDIO_CODEC	21
+#define CLK_BUS_DSP_MSG		22
+#define CLK_BUS_DSP_CFG		23
+#define CLK_BUS_MCU_NPU_ACLK	24
+#define CLK_BUS_MCU_NPU_HCLK	25
+#define CLK_MCU_TIMER0		27
+#define CLK_MCU_TIMER1		28
+#define CLK_MCU_TIMER2		29
+#define CLK_MCU_TIMER3		30
+#define CLK_MCU_TIMER4		31
+#define CLK_MCU_TIMER5		32
+#define CLK_BUS_MCU_TIMER	33
+#define CLK_BUS_MCU_DMA		34
+#define CLK_BUS_MCU_TZMA0	35
+#define CLK_BUS_MCU_TZMA1	36
+#define CLK_BUS_PUBSRAM		37
+#define CLK_BUS_MCU_MBUS	38
+#define CLK_BUS_MCU_DMA_MBUS	39
+#define CLK_BUS_RV		40
+#define CLK_BUS_RV_CFG		41
+#define CLK_BUS_MCU_RISCV_MSG	42
+#define CLK_MCU_PWM		43
+#define CLK_BUS_MCU_PWM		44
+#define CLK_BUS_MCU_AHB_AUTO	45
+
+#define CLK_MCU_NUMBER		(CLK_BUS_MCU_AHB_AUTO + 1)
+
+#endif /* _DT_BINDINGS_CLK_SUN55IW3_MCU_CCU_H_ */
diff --git a/include/dt-bindings/display/lcd_command.h b/include/dt-bindings/display/lcd_command.h
new file mode 100644
index 000000000000..486c32757946
--- /dev/null
+++ b/include/dt-bindings/display/lcd_command.h
@@ -0,0 +1,48 @@
+/* SPDX-License-Identifier: GPL-2.0-or-later */
+/* Copyright(c) 2020 - 2023 Allwinner Technology Co.,Ltd. All rights reserved. */
+#ifndef __LCD_COMMAND_H__
+#define  __LCD_COMMAND_H__
+
+		/* void (*p_func)(u32 sel) */
+#define	SUNXI_LCD_TCON_ENABLE              0
+#define	SUNXI_LCD_TCON_DISABLE             1
+#define	SUNXI_LCD_BACKLIGHT_ENABLE         2
+#define	SUNXI_LCD_BACKLIGHT_DISABLE        3
+
+		/* s32 (*p_func)(u32 sel) */
+#define	SUNXI_LCD_PWM_ENABLE               10
+#define	SUNXI_LCD_PWM_DISABLE              11
+#define	SUNXI_LCD_CPU_SET_AUTO_MODE        12
+#define	SUNXI_LCD_DSI_CLK_ENABLE           13
+#define	SUNXI_LCD_DSI_CLK_DISABLE          14
+
+		/* void (*p_func)(u32 sel, u32, u32) */
+#define	SUNXI_LCD_DSI_MODE_SWITCH          20
+
+		/* s32 (*p_func)(u32) */
+#define	SUNXI_LCD_DELAY_MS                 30
+#define	SUNXI_LCD_DELAY_US                 31
+
+		/* void (*p_func)(u32 sel, u32) */
+#define	SUNXI_LCD_POWER_ENABLE             40
+#define	SUNXI_LCD_POWER_DISABLE            41
+#define	SUNXI_LCD_CPU_WRITE_INDEX          42
+#define	SUNXI_LCD_CPU_WRITE_DATA           43
+#define	SUNXI_LCD_DSI_SET_MAX_RET_SIZE     44
+#define	SUNXI_LCD_PIN_CFG                  45
+
+		/* s32 (*p_func)(u32 sel, u32, u32) */
+#define	SUNXI_LCD_CPU_WRITE                50
+#define	SUNXI_LCD_GPIO_SET_VALUE           51
+#define	SUNXI_LCD_GPIO_SET_DIRECTION       52
+
+		/* s32 (*p_func)(u32 sel, u8, u8 *, u32 *) */
+#define	SUNXI_LCD_DSI_DCS_READ             80
+
+		/* s32 (*p_func)(u32 sel, u8, u8 *, u32) */
+#define	DSI_DCS_WR                         90
+#define	SUNXI_LCD_DSI_DCS_WRITE            91
+#define	SUNXI_LCD_DSI_GEN_WRITE            92
+
+
+#endif
diff --git a/include/dt-bindings/display/sunxi-lcd.h b/include/dt-bindings/display/sunxi-lcd.h
new file mode 100644
index 000000000000..0457ad44dbf1
--- /dev/null
+++ b/include/dt-bindings/display/sunxi-lcd.h
@@ -0,0 +1,25 @@
+/* SPDX-License-Identifier: GPL-2.0-or-later */
+/* Copyright(c) 2020 - 2023 Allwinner Technology Co.,Ltd. All rights reserved. */
+#ifndef __SUNXI_LCD_H__
+#define  __SUNXI_LCD_H__
+
+/* displl */
+#define CLK_PLL_DISPLL		0
+#define CLK_DSI_LS		1
+#define CLK_DSI_HS		2
+#define CLK_LVDS_OR_RGB		3
+
+/* dsi */
+#define MIPI_DSI_MODE_VIDEO		1
+#define MIPI_DSI_MODE_VIDEO_BURST	(1<<1)
+#define MIPI_DSI_MODE_NO_EOT_PACKET	(1<<9)
+#define MIPI_DSI_CLOCK_NON_CONTINUOUS	(1<<10)
+#define MIPI_DSI_SLAVE_MODE		(1<<22)
+#define MIPI_DSI_TO_INCELL		(1<<23)
+
+/* lvds */
+#define MEDIA_BUS_FMT_RGB666_1X7X3_SPWG         0x1010
+#define MEDIA_BUS_FMT_RGB888_1X7X4_SPWG         0x1011
+#define MEDIA_BUS_FMT_RGB888_1X7X4_JEIDA        0x1012
+
+#endif
diff --git a/include/dt-bindings/power/a523-power.h b/include/dt-bindings/power/a523-power.h
new file mode 100644
index 000000000000..bea74bad660d
--- /dev/null
+++ b/include/dt-bindings/power/a523-power.h
@@ -0,0 +1,18 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+#ifndef __DT_BINDINGS_POWER_A523_H__
+#define __DT_BINDINGS_POWER_A523_H__
+
+#define A523_PD_DSP			0
+#define A523_PD_NPU			1
+#define A523_PD_AUDIO		2
+#define A523_PD_SRAM		3
+#define A523_PD_RISCV		4
+#define A523_PCK_VE			0
+#define A523_PCK_GPU		1
+#define A523_PCK_VI			2
+#define A523_PCK_VO0		3
+#define A523_PCK_VO1		4
+#define A523_PCK_DE			5
+#define A523_PCK_NAND		6
+#define A523_PCK_PCIE		7
+#endif
diff --git a/include/dt-bindings/reset/sun55i-a523-ccu.h b/include/dt-bindings/reset/sun55i-a523-ccu.h
index 70df503f34fe..e5d788078ad3 100644
--- a/include/dt-bindings/reset/sun55i-a523-ccu.h
+++ b/include/dt-bindings/reset/sun55i-a523-ccu.h
@@ -82,7 +82,8 @@
 #define RST_BUS_VIDEO_OUT0	73
 #define RST_BUS_VIDEO_OUT1	74
 #define RST_BUS_LEDC		75
 #define RST_BUS_CSI		76
 #define RST_BUS_ISP		77
+#define RST_BUS_USB_3		78
 
 #endif /* _DT_BINDINGS_RST_SUN55I_A523_CCU_H_ */
diff --git a/include/dt-bindings/reset/sun55iw3-mcu-ccu.h b/include/dt-bindings/reset/sun55iw3-mcu-ccu.h
new file mode 100644
index 000000000000..c849a3657b0e
--- /dev/null
+++ b/include/dt-bindings/reset/sun55iw3-mcu-ccu.h
@@ -0,0 +1,31 @@
+/* SPDX-License-Identifier: (GPL-2.0+ or MIT) */
+/* Copyright(c) 2020 - 2023 Allwinner Technology Co.,Ltd. All rights reserved. */
+/*
+ * Copyright (C) 2022 rengaomin@allwinnertech.com
+ */
+
+#ifndef _DT_BINDINGS_RST_SUN55IW3_MCU_CCU_H_
+#define _DT_BINDINGS_RST_SUN55IW3_MCU_CCU_H_
+
+#define RST_BUS_MCU_I2S3	0
+#define RST_BUS_MCU_I2S2	1
+#define RST_BUS_MCU_I2S1	2
+#define RST_BUS_MCU_I2S0	3
+#define RST_BUS_MCU_OWA		4
+#define RST_BUS_MCU_DMIC	5
+#define RST_BUS_MCU_AUDIO_CODEC	6
+#define RST_BUS_DSP_MSG		7
+#define RST_BUS_DSP_CFG		8
+#define RST_BUS_MCU_NPU		9
+#define RST_BUS_MCU_TIME	10
+#define RST_BUS_DSP		11
+#define RST_BUS_DSP_DBG		12
+#define RST_BUS_MCU_DMA		13
+#define RST_BUS_PUBSRAM		14
+#define RST_BUS_RV		15
+#define RST_BUS_RV_DBG		16
+#define RST_BUS_RV_CFG		17
+#define RST_BUS_MCU_RV_MSG	18
+#define RST_BUS_MCU_PWM		19
+
+#endif /* _DT_BINDINGS_RST_SUN55IW3_MCU_CCU_H_ */
diff --git a/include/dt-bindings/spi/sunxi-spi.h b/include/dt-bindings/spi/sunxi-spi.h
new file mode 100644
index 000000000000..179bc59a1c95
--- /dev/null
+++ b/include/dt-bindings/spi/sunxi-spi.h
@@ -0,0 +1,18 @@
+/* SPDX-License-Identifier: GPL-2.0-or-later */
+/* Copyright(c) 2020 - 2023 Allwinner Technology Co.,Ltd. All rights reserved. */
+
+#ifndef __DT_SUNXI_SPI_H
+#define __DT_SUNXI_SPI_H
+
+#define SUNXI_SPI_BUS_MASTER	(1 << 0)
+#define SUNXI_SPI_BUS_SLAVE		(1 << 1)
+#define SUNXI_SPI_BUS_DBI		(1 << 2)
+#define SUNXI_SPI_BUS_BIT		(1 << 3)
+#define SUNXI_SPI_BUS_NOR		(1 << 4)
+#define SUNXI_SPI_BUS_NAND		(1 << 5)
+#define SUNXI_SPI_BUS_CAMERA	(1 << 6)
+
+#define SUNXI_SPI_CS_AUTO	0
+#define SUNXI_SPI_CS_SOFT	1
+
+#endif /* __DT_SUNXI_SPI_H */
diff --git a/include/errcode/sunxi-err-audio.h b/include/errcode/sunxi-err-audio.h
new file mode 100644
index 000000000000..dc9a6be84293
--- /dev/null
+++ b/include/errcode/sunxi-err-audio.h
@@ -0,0 +1,61 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/* Copyright(c) 2020 - 2023 Allwinner Technology Co.,Ltd. All rights reserved. */
+/*
+ * Allwinner's errcode for audio
+ *
+ * Copyright (c) 2023, zhouxijing <zhouxijing@allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ */
+
+#ifndef __SUNXI_ERR_AUDIO_H__
+#define __SUNXI_ERR_AUDIO_H__
+
+enum sunxi_err_audio_func {
+	MOD_INIT = 0x0,
+	PLAT_PROBE,
+	MEM_INIT,
+	CLK_INIT,
+	PIN_INIT,
+	COMP_PROBE,
+	UCFMT_CB,
+	HW_PARAMS,
+	DAIFMT_SET,
+	DAIFMT_GET,
+	CLK_SET,
+	DUMP_STORE,
+	DUMP_SHOW,
+	DUMP_VER,
+	HW_IRQ,
+
+	E_SWARG_END = 0xFFFF,
+};
+
+enum sunxi_err_audio {
+	E_I2S_HW_IRQ	       = E_I2S_HW_ERR0	   | E_USER(HW_IRQ),
+	E_I2S_SWDEP_MEM_INIT   = E_I2S_SW_DEP_ERR0 | E_USER(MEM_INIT),
+	E_I2S_SWDEP_CLK_INIT   = E_I2S_SW_DEP_ERR0 | E_USER(CLK_INIT),
+	E_I2S_SWDEP_PIN_INIT   = E_I2S_SW_DEP_ERR0 | E_USER(PIN_INIT),
+	E_I2S_SWSYS_MOD_INIT   = E_I2S_SW_SYS_ERR0 | E_USER(MOD_INIT),
+	E_I2S_SWSYS_PLAT_PROBE = E_I2S_SW_SYS_ERR0 | E_USER(PLAT_PROBE),
+	E_I2S_SWSYS_COMP_PROBE = E_I2S_SW_SYS_ERR0 | E_USER(COMP_PROBE),
+	E_I2S_SWARG_UCFMT_CB   = E_I2S_SW_ARG_ERR0 | E_USER(UCFMT_CB),
+	E_I2S_SWARG_HW_PARAMS  = E_I2S_SW_ARG_ERR0 | E_USER(HW_PARAMS),
+	E_I2S_SWARG_DAIFMT_SET = E_I2S_SW_ARG_ERR0 | E_USER(DAIFMT_SET),
+	E_I2S_SWARG_DAIFMT_GET = E_I2S_SW_ARG_ERR0 | E_USER(DAIFMT_GET),
+	E_I2S_SWARG_CLK_SET    = E_I2S_SW_ARG_ERR0 | E_USER(CLK_SET),
+	E_I2S_SWARG_DUMP_STORE = E_I2S_SW_ARG_ERR0 | E_USER(DUMP_STORE),
+	E_I2S_SWARG_DUMP_SHOW  = E_I2S_SW_ARG_ERR0 | E_USER(DUMP_SHOW),
+	E_I2S_SWARG_DUMP_VER   = E_I2S_SW_ARG_ERR0 | E_USER(DUMP_VER),
+};
+
+#endif
diff --git a/include/errcode/sunxi-err.h b/include/errcode/sunxi-err.h
new file mode 100644
index 000000000000..4a6c1f3bb410
--- /dev/null
+++ b/include/errcode/sunxi-err.h
@@ -0,0 +1,199 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/* Copyright(c) 2020 - 2023 Allwinner Technology Co.,Ltd. All rights reserved. */
+/*
+ * Allwinner's errcode
+ *
+ * Copyright (c) 2023, lvda <lvda@allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ */
+
+#ifndef __SUNXI_ERR_H__
+#define __SUNXI_ERR_H__
+
+/*
+ * SUNXI ERRCODE format:
+ * |	bit31	|	bit30:bit20	|	bit19:bit16	|	bit15:bit0	|
+ * |------------|-----------------------|-----------------------|-----------------------|
+ * |	1	|	MOD + SUBMOD	|	BUG TYPE	|	USER-DEF	|
+ */
+#define E_MOD_OFFSET	20
+#define E_TYPE_OFFSET	16
+#define E_USER_OFFSET	0
+
+/* Error code is negative */
+#define E_MOD(mod)	(BIT(31) | ((mod & 0x7FF) << E_MOD_OFFSET))
+#define E_TYPE(type)	((type & 0xF) << E_TYPE_OFFSET)
+#define E_USER(user)	((user & 0xFFFF) << E_USER_OFFSET)
+
+/*
+ * SUNXI ERR type:
+ * E_TYPE_HW:		IP error, include abnormal interruption
+ * E_TYPE_SW_DEP:	The module that it depends on has issues
+ * E_TYPE_SW_SYS:	The system interface has error
+ * E_TYPE_SW_ARG:	The parameter passing error, including system call parameter, DTS parameters
+ *
+ */
+enum sunxi_err_type {
+	E_TYPE_HW = 0,
+	E_TYPE_SW_DEP,
+	E_TYPE_SW_SYS,
+	E_TYPE_SW_ARG,
+
+	E_TYPE_OTHER = 15,
+};
+
+/*
+ * SUNXI module names
+ */
+enum sunxi_err_mod {
+	/* basic-system */
+	E_MOD_SYS	= 0x0,
+	E_MOD_CLK	= 0x40,
+	E_MOD_CLK_NG,
+	E_MOD_PIN	= 0x50,
+	E_MOD_INT	= 0x60,
+	E_MOD_UART	= 0x70,
+	E_MOD_UART_NG,
+	E_MOD_TIMER	= 0x80,
+	E_MOD_TIMER_HS,
+	E_MOD_WDT	= 0x90,
+	E_MOD_DMA	= 0xA0,
+	E_MOD_RTC	= 0xB0,
+	E_MOD_PMIC	= 0xC0,
+	/* highspeed-peripheral-system */
+	E_MOD_GMAC	= 0x100,
+	E_MOD_PCIE	= 0x140,
+	E_MOD_USB	= 0x180,
+	E_MOD_MMC	= 0x1C0,
+	/* lowspeed-peripheral-system */
+	E_MOD_PWM	= 0x200,
+	E_MOD_IR	= 0x210,
+	E_MOD_TWI	= 0x220,
+	E_MOD_ADC	= 0x230,
+	E_MOD_LEDC	= 0x240,
+	E_MOD_SPI	= 0x250,
+	/* AMP system */
+	E_MOD_HWLOCK	= 0x260,
+	E_MOD_MSGBOX	= 0x270,
+	/* secure system */
+	E_MOD_CE	= 0x280,
+	E_MOD_SID	= 0x2C0,
+	/* graphic system */
+	E_MOD_G2D	= 0x300,
+	E_MOD_DE	= 0x340,
+	E_MOD_GPU	= 0x380,
+	/* multimedia system */
+	E_MOD_VE	= 0x3C0,
+	E_MOD_CSI	= 0x400,
+	E_MOD_ISP	= 0x440,
+	/* audio system */
+	E_MOD_AUDIO	 = 0x480,
+	E_MOD_AUDIOCODEC = 0x481,
+	E_MOD_I2S	 = 0x482,
+	E_MOD_DMIC	 = 0x483,
+	E_MOD_OWA	 = 0x484,
+	E_MOD_AHUB 	 = 0x485,
+
+	E_MOD_END	= 0x800, /* Do not use */
+};
+
+enum sunxi_err_code {
+	E_SYS_HW_ERR0		= E_MOD(E_MOD_SYS) | E_TYPE(E_TYPE_HW) | 0x0,
+
+	E_CLK_HW_ERR0		= E_MOD(E_MOD_CLK) | E_TYPE(E_TYPE_HW) | 0x0,
+
+	E_PIN_HW_ERR0		= E_MOD(E_MOD_PIN) | E_TYPE(E_TYPE_HW) | 0x0,
+
+	E_INT_HW_ERR0		= E_MOD(E_MOD_INT) | E_TYPE(E_TYPE_HW) | 0x0,
+
+	E_UART_HW_ERR0		= E_MOD(E_MOD_UART) | E_TYPE(E_TYPE_HW) | 0x0,
+
+	E_TIMER_HW_ERR0		= E_MOD(E_MOD_TIMER) | E_TYPE(E_TYPE_HW) | 0x0,
+
+	E_WDT_HW_ERR0		= E_MOD(E_MOD_WDT) | E_TYPE(E_TYPE_HW) | 0x0,
+
+	E_DMA_HW_ERR0		= E_MOD(E_MOD_DMA) | E_TYPE(E_TYPE_HW) | 0x0,
+
+	E_RTC_HW_ERR0		= E_MOD(E_MOD_RTC) | E_TYPE(E_TYPE_HW) | 0x0,
+
+	E_PMIC_HW_ERR0		= E_MOD(E_MOD_PMIC) | E_TYPE(E_TYPE_HW) | 0x0,
+
+	E_GMAC_HW_ERR0		= E_MOD(E_MOD_GMAC) | E_TYPE(E_TYPE_HW) | 0x0,
+
+	E_PCIE_HW_ERR0		= E_MOD(E_MOD_PCIE) | E_TYPE(E_TYPE_HW) | 0x0,
+
+	E_USB_HW_ERR0		= E_MOD(E_MOD_USB) | E_TYPE(E_TYPE_HW) | 0x0,
+
+	E_MMC_HW_ERR0		= E_MOD(E_MOD_MMC) | E_TYPE(E_TYPE_HW) | 0x0,
+
+	E_PWM_HW_ERR0		= E_MOD(E_MOD_PWM) | E_TYPE(E_TYPE_HW) | 0x0,
+
+	E_IR_HW_ERR0		= E_MOD(E_MOD_IR) | E_TYPE(E_TYPE_HW) | 0x0,
+
+	E_TWI_HW_ERR0		= E_MOD(E_MOD_TWI) | E_TYPE(E_TYPE_HW) | 0x0,
+
+	E_ADC_HW_ERR0		= E_MOD(E_MOD_ADC) | E_TYPE(E_TYPE_HW) | 0x0,
+
+	E_LEDC_HW_ERR0		= E_MOD(E_MOD_LEDC) | E_TYPE(E_TYPE_HW) | 0x0,
+
+	E_SPI_HW_ERR0		= E_MOD(E_MOD_SPI) | E_TYPE(E_TYPE_HW) | 0x0,
+
+	E_HWLOCK_HW_ERR0	= E_MOD(E_MOD_HWLOCK) | E_TYPE(E_TYPE_HW) | 0x0,
+
+	E_MSGBOX_HW_ERR0	= E_MOD(E_MOD_MSGBOX) | E_TYPE(E_TYPE_HW) | 0x0,
+
+	E_CE_HW_ERR0		= E_MOD(E_MOD_CE) | E_TYPE(E_TYPE_HW) | 0x0,
+
+	E_SID_HW_ERR0		= E_MOD(E_MOD_SID) | E_TYPE(E_TYPE_HW) | 0x0,
+
+	E_G2D_HW_ERR0		= E_MOD(E_MOD_G2D) | E_TYPE(E_TYPE_HW) | 0x0,
+
+	E_DE_HW_ERR0		= E_MOD(E_MOD_DE) | E_TYPE(E_TYPE_HW) | 0x0,
+
+	E_GPU_HW_ERR0		= E_MOD(E_MOD_GPU) | E_TYPE(E_TYPE_HW) | 0x0,
+
+	E_VE_HW_ERR0		= E_MOD(E_MOD_VE) | E_TYPE(E_TYPE_HW) | 0x0,
+
+	E_CSI_HW_ERR0		= E_MOD(E_MOD_CSI) | E_TYPE(E_TYPE_HW) | 0x0,
+
+	E_ISP_HW_ERR0		= E_MOD(E_MOD_ISP) | E_TYPE(E_TYPE_HW) | 0x0,
+
+	E_AUDIO_HW_ERR0			= E_MOD(E_MOD_AUDIO) | E_TYPE(E_TYPE_HW)     | 0x0,
+	E_AUDIO_SW_DEP_ERR0		= E_MOD(E_MOD_AUDIO) | E_TYPE(E_TYPE_SW_DEP) | 0x0,
+	E_AUDIO_SW_SYS_ERR0		= E_MOD(E_MOD_AUDIO) | E_TYPE(E_TYPE_SW_SYS) | 0x0,
+	E_AUDIO_SW_ARG_ERR0		= E_MOD(E_MOD_AUDIO) | E_TYPE(E_TYPE_SW_ARG) | 0x0,
+	E_AUDIOCODEC_HW_ERR0		= E_MOD(E_MOD_AUDIOCODEC) | E_TYPE(E_TYPE_HW)     | 0x0,
+	E_AUDIOCODEC_SW_DEP_ERR0	= E_MOD(E_MOD_AUDIOCODEC) | E_TYPE(E_TYPE_SW_DEP) | 0x0,
+	E_AUDIOCODEC_SW_SYS_ERR0	= E_MOD(E_MOD_AUDIOCODEC) | E_TYPE(E_TYPE_SW_SYS) | 0x0,
+	E_AUDIOCODEC_SW_ARG_ERR0	= E_MOD(E_MOD_AUDIOCODEC) | E_TYPE(E_TYPE_SW_ARG) | 0x0,
+	E_I2S_HW_ERR0			= E_MOD(E_MOD_I2S)   | E_TYPE(E_TYPE_HW)     | 0x0,
+	E_I2S_SW_DEP_ERR0		= E_MOD(E_MOD_I2S)   | E_TYPE(E_TYPE_SW_DEP) | 0x0,
+	E_I2S_SW_SYS_ERR0		= E_MOD(E_MOD_I2S)   | E_TYPE(E_TYPE_SW_SYS) | 0x0,
+	E_I2S_SW_ARG_ERR0		= E_MOD(E_MOD_I2S)   | E_TYPE(E_TYPE_SW_ARG) | 0x0,
+	E_DMIC_HW_ERR0			= E_MOD(E_MOD_DMIC)  | E_TYPE(E_TYPE_HW)     | 0x0,
+	E_DMIC_SW_DEP_ERR0		= E_MOD(E_MOD_DMIC)  | E_TYPE(E_TYPE_SW_DEP) | 0x0,
+	E_DMIC_SW_SYS_ERR0		= E_MOD(E_MOD_DMIC)  | E_TYPE(E_TYPE_SW_SYS) | 0x0,
+	E_DMIC_SW_ARG_ERR0		= E_MOD(E_MOD_DMIC)  | E_TYPE(E_TYPE_SW_ARG) | 0x0,
+	E_OWA_HW_ERR0			= E_MOD(E_MOD_OWA)   | E_TYPE(E_TYPE_HW)     | 0x0,
+	E_OWA_SW_DEP_ERR0		= E_MOD(E_MOD_OWA)   | E_TYPE(E_TYPE_SW_DEP) | 0x0,
+	E_OWA_SW_SYS_ERR0		= E_MOD(E_MOD_OWA)   | E_TYPE(E_TYPE_SW_SYS) | 0x0,
+	E_OWA_SW_ARG_ERR0		= E_MOD(E_MOD_OWA)   | E_TYPE(E_TYPE_SW_ARG) | 0x0,
+	E_AHUB_HW_ERR0			= E_MOD(E_MOD_AHUB)  | E_TYPE(E_TYPE_HW)     | 0x0,
+	E_AHUB_SW_DEP_ERR0		= E_MOD(E_MOD_AHUB)  | E_TYPE(E_TYPE_SW_DEP) | 0x0,
+	E_AHUB_SW_SYS_ERR0		= E_MOD(E_MOD_AHUB)  | E_TYPE(E_TYPE_SW_SYS) | 0x0,
+	E_AHUB_SW_ARG_ERR0		= E_MOD(E_MOD_AHUB)  | E_TYPE(E_TYPE_SW_ARG) | 0x0,
+};
+
+#include "sunxi-err-audio.h"
+
+#endif
diff --git a/include/sunxi-dma.h b/include/sunxi-dma.h
new file mode 100644
index 000000000000..a30a13b93d45
--- /dev/null
+++ b/include/sunxi-dma.h
@@ -0,0 +1,33 @@
+/* SPDX-License-Identifier: GPL-2.0-or-later */
+/* Copyright(c) 2020 - 2023 Allwinner Technology Co.,Ltd. All rights reserved. */
+/*
+ * SUNXI DMA support
+ *
+ * Copyright (C) 2015 AllWinnertech Ltd.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#ifndef __SUNXI_DMA_H
+#define __SUNXI_DMA_H
+
+typedef void (*sunxi_dma_timeout_callback)(void *param);
+
+struct sunxi_dma_desc {
+	bool is_bmode;
+	bool is_timeout;
+	unsigned timeout_steps; /* the steps is the time for channel timer,the max is 511,1 step = 20.48us */
+	unsigned timeout_fun; /* the fun is used to set the timout interrupt peding fun,0x01 is pause,0x10 is end,0x11 is next descrp */
+	sunxi_dma_timeout_callback callback;
+	void *callback_param;
+};
+
+#endif
diff --git a/include/sunxi-gpio.h b/include/sunxi-gpio.h
new file mode 100644
index 000000000000..6bb957eda5c5
--- /dev/null
+++ b/include/sunxi-gpio.h
@@ -0,0 +1,188 @@
+/* SPDX-License-Identifier: GPL-2.0-or-later */
+/* Copyright(c) 2020 - 2023 Allwinner Technology Co.,Ltd. All rights reserved. */
+/*
+ * (C) Copyright 2015-2020
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * Wim Hwang <huangwei@allwinnertech.com>
+ *
+ * sunxi gpio utils
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ */
+
+#ifndef __SW_GPIO_H
+#define __SW_GPIO_H
+
+#define SUNXI_PINCTRL	"pio"
+#define SUNXI_R_PINCTRL	"r_pio"
+#include <linux/pinctrl/pinconf-generic.h>
+
+/* pin group base number name space,
+ * the max pin number : 26*32=832.
+ */
+#define SUNXI_BANK_SIZE 32
+#define SUNXI_PA_BASE	0
+#define SUNXI_PB_BASE	32
+#define SUNXI_PC_BASE	64
+#define SUNXI_PD_BASE	96
+#define SUNXI_PE_BASE	128
+#define SUNXI_PF_BASE	160
+#define SUNXI_PG_BASE	192
+#define SUNXI_PH_BASE	224
+#define SUNXI_PI_BASE	256
+#define SUNXI_PJ_BASE	288
+#define SUNXI_PK_BASE	320
+#define SUNXI_PL_BASE	352
+#define SUNXI_PM_BASE	384
+#define SUNXI_PN_BASE	416
+#define SUNXI_PO_BASE	448
+#define AXP_PIN_BASE	1024
+
+#define SUNXI_PIN_NAME_MAX_LEN	8
+
+/* sunxi gpio name space */
+#define GPIOA(n)	(SUNXI_PA_BASE + (n))
+#define GPIOB(n)	(SUNXI_PB_BASE + (n))
+#define GPIOC(n)	(SUNXI_PC_BASE + (n))
+#define GPIOD(n)	(SUNXI_PD_BASE + (n))
+#define GPIOE(n)	(SUNXI_PE_BASE + (n))
+#define GPIOF(n)	(SUNXI_PF_BASE + (n))
+#define GPIOG(n)	(SUNXI_PG_BASE + (n))
+#define GPIOH(n)	(SUNXI_PH_BASE + (n))
+#define GPIOI(n)	(SUNXI_PI_BASE + (n))
+#define GPIOJ(n)	(SUNXI_PJ_BASE + (n))
+#define GPIOK(n)	(SUNXI_PK_BASE + (n))
+#define GPIOL(n)	(SUNXI_PL_BASE + (n))
+#define GPIOM(n)	(SUNXI_PM_BASE + (n))
+#define GPION(n)	(SUNXI_PN_BASE + (n))
+#define GPIOO(n)	(SUNXI_PO_BASE + (n))
+#define GPIO_AXP(n)	(AXP_PIN_BASE  + (n))
+
+/* sunxi specific input/output/eint functions */
+#define SUNXI_PIN_INPUT_FUNC	(0)
+#define SUNXI_PIN_OUTPUT_FUNC	(1)
+#define SUNXI_PIN_EINT_FUNC	(6)
+#define SUNXI_PIN_IO_DISABLE	(7)
+
+/* axp group base number name space,
+ * axp pinctrl number space coherent to sunxi-pinctrl.
+ */
+#define AXP_PINCTRL	        "axp-pinctrl"
+#define AXP_CFG_GRP		(0xFFFF)
+#define AXP_PIN_INPUT_FUNC	(0)
+#define AXP_PIN_OUTPUT_FUNC	(1)
+#define IS_AXP_PIN(pin)		(pin >= AXP_PIN_BASE)
+
+/* sunxi specific pull up/down */
+enum sunxi_pull_up_down {
+	SUNXI_PULL_DISABLE = 0,
+	SUNXI_PULL_UP,
+	SUNXI_PULL_DOWN,
+};
+
+/* sunxi specific data types */
+enum sunxi_data_type {
+	SUNXI_DATA_LOW = 0,
+	SUNXI_DATA_HIGH = 0,
+};
+
+/* sunxi specific pull status */
+enum sunxi_pin_pull {
+	SUNXI_PIN_PULL_DISABLE	= 0x00,
+	SUNXI_PIN_PULL_UP	= 0x01,
+	SUNXI_PIN_PULL_DOWN	= 0x02,
+	SUNXI_PIN_PULL_RESERVED	= 0x03,
+};
+
+/* sunxi specific driver levels */
+enum sunxi_pin_drv_level {
+	SUNXI_DRV_LEVEL0 = 10,
+	SUNXI_DRV_LEVEL1 = 20,
+	SUNXI_DRV_LEVEL2 = 30,
+	SUNXI_DRV_LEVEL3 = 40,
+};
+
+/* sunxi specific data bit status */
+enum sunxi_pin_data_status {
+	SUNXI_PIN_DATA_LOW  = 0x00,
+	SUNXI_PIN_DATA_HIGH = 0x01,
+};
+
+/* sunxi pin interrupt trigger mode */
+enum sunxi_pin_int_trigger_mode {
+	SUNXI_PIN_EINT_POSITIVE_EDGE   =   0x0,
+	SUNXI_PIN_EINT_NEGATIVE_EDGE   =   0x1,
+	SUNXI_PIN_EINT_HIGN_LEVEL      =   0x2,
+	SUNXI_PIN_EINT_LOW_LEVEL       =   0x3,
+	SUNXI_PIN_EINT_DOUBLE_EDGE     =   0x4
+};
+
+/* the source clock of pin int */
+enum sunxi_pin_int_source_clk {
+	SUNXI_PIN_INT_SRC_CLK_32K = 0x0,
+	SUNXI_PIN_INT_SRC_CLK_24M = 0x1
+};
+
+/*
+ * pin configuration (pull up/down and drive strength) type and its value are
+ * packed together into a 32-bits. The lower 8-bits represent the configuration
+ * type and the upper 24-bits hold the value of the configuration type.
+ */
+#define SUNXI_PINCFG_PACK(type, value)	(((value) << 8) | (type & 0xFF))
+#define SUNXI_PINCFG_UNPACK_TYPE(cfg)	((cfg) & 0xFF)
+#define SUNXI_PINCFG_UNPACK_VALUE(cfg)	(((cfg) & 0xFFFFFF00) >> 8)
+
+static inline int sunxi_gpio_to_name(int gpio, char *name)
+{
+	int bank, index;
+
+	if (!name)
+		return -EINVAL;
+
+	if (IS_AXP_PIN(gpio)) {
+		/* axp gpio name like this : GPIO0/GPIO1/.. */
+		index = gpio - AXP_PIN_BASE;
+		sprintf(name, "GPIO%d", index);
+	} else {
+		/* sunxi gpio name like this : PA0/PA1/PB0 */
+		bank = gpio / SUNXI_BANK_SIZE;
+		index = gpio % SUNXI_BANK_SIZE;
+		sprintf(name, "P%c%d", ('A' + bank), index);
+	}
+
+	return 0;
+}
+
+/* pio end, invalid macro */
+#define GPIO_INDEX_INVALID	(0xFFFFFFF0)
+#define GPIO_CFG_INVALID	(0xEEEEEEEE)
+#define GPIO_PULL_INVALID	(0xDDDDDDDD)
+#define GPIO_DRVLVL_INVALID	(0xCCCCCCCC)
+#define IRQ_NUM_INVALID		(0xFFFFFFFF)
+#define AXP_PORT_VAL		(0x0000FFFF)
+
+/* pio default macro */
+#define GPIO_PULL_DEFAULT	((u32)-1)
+#define GPIO_DRVLVL_DEFAULT	((u32)-1)
+#define GPIO_DATA_DEFAULT	((u32)-1)
+
+/*
+ * struct gpio_config - gpio config info
+ * @gpio:      gpio global index, must be unique
+ * @mul_sel:   multi sel val: 0 - input, 1 - output.
+ * @pull:      pull val: 0 - pull up/down disable, 1 - pull up
+ * @drv_level: driver level val: 0 - level 0, 1 - level 1
+ * @data:      data val: 0 - low, 1 - high, only valid when mul_sel is input/output
+ */
+struct gpio_config {
+	u32	data;
+	u32	gpio;
+	u32	mul_sel;
+	u32	pull;
+	u32	drv_level;
+};
+
+#endif
diff --git a/include/sunxi-inno.h b/include/sunxi-inno.h
new file mode 100644
index 000000000000..0065c6dee828
--- /dev/null
+++ b/include/sunxi-inno.h
@@ -0,0 +1,10 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/* Copyright(c) 2020 - 2023 Allwinner Technology Co.,Ltd. All rights reserved. */
+#ifndef _SUNXI_INNO_H
+#define _SUNXI_INNO_H
+
+#include <linux/notifier.h>
+
+extern struct atomic_notifier_head inno_subsys_notifier_list;
+
+#endif	/* _SUNXI_INNO_H */
diff --git a/include/sunxi-iommu.h b/include/sunxi-iommu.h
new file mode 100644
index 000000000000..ad14c3b44f40
--- /dev/null
+++ b/include/sunxi-iommu.h
@@ -0,0 +1,52 @@
+/* SPDX-License-Identifier: GPL-2.0-or-later */
+/* Copyright(c) 2020 - 2023 Allwinner Technology Co.,Ltd. All rights reserved. */
+/*
+ *
+ * Copyright (C) 2015 AllWinnertech Ltd.
+ *
+ * Author: huangshuosheng <huangshuosheng@allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#ifndef __LINUX_SUNXI_IOMMU_H
+#define __LINUX_SUNXI_IOMMU_H
+#include <linux/iommu.h>
+#include <linux/iova.h>
+
+typedef void (*sunxi_iommu_fault_cb)(void);
+extern void sunxi_iommu_register_fault_cb(sunxi_iommu_fault_cb cb, unsigned int master_id);
+extern void sunxi_enable_device_iommu(unsigned int master_id, bool flag);
+extern void sunxi_reset_device_iommu(unsigned int master_id);
+extern struct iommu_domain *global_iommu_domain;
+ssize_t sunxi_iommu_dump_pgtable(char *buf, size_t buf_len,
+					       bool for_sysfs_show);
+
+enum iommu_dma_cookie_type {
+	IOMMU_DMA_IOVA_COOKIE,
+	IOMMU_DMA_MSI_COOKIE,
+};
+
+struct iommu_dma_cookie {
+	enum iommu_dma_cookie_type	type;
+	union {
+		/* Full allocator for IOMMU_DMA_IOVA_COOKIE */
+		struct iova_domain	iovad;
+		/* Trivial linear page allocator for IOMMU_DMA_MSI_COOKIE */
+		dma_addr_t		msi_iova;
+	};
+	struct list_head		msi_page_list;
+
+	/* Domain for flush queue callback; NULL if flush queue not in use */
+	struct iommu_domain		*fq_domain;
+};
+
+#endif  /* __LINUX_SUNXI_IOMMU_H */
diff --git a/include/sunxi-log.h b/include/sunxi-log.h
new file mode 100644
index 000000000000..3020acf50a24
--- /dev/null
+++ b/include/sunxi-log.h
@@ -0,0 +1,176 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/* Copyright(c) 2020 - 2023 Allwinner Technology Co.,Ltd. All rights reserved. */
+/*
+ * Allwinner's log functions
+ *
+ * Copyright (c) 2023, lvda <lvda@allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ */
+
+#ifndef __SUNXI_LOG_H__
+#define __SUNXI_LOG_H__
+
+#define SUNXI_LOG_VERSION	"V0.7"
+/* Allow user to define their own MODNAME with `SUNXI_MODNAME` */
+#ifndef SUNXI_MODNAME
+#define SUNXI_MODNAME		KBUILD_MODNAME
+#endif
+
+#ifdef pr_fmt
+#undef pr_fmt
+#endif
+
+#ifdef dev_fmt
+#undef dev_fmt
+#endif
+
+#define pr_fmt(fmt)		"sunxi:" SUNXI_MODNAME fmt
+#define dev_fmt			pr_fmt
+
+#include <linux/kernel.h>
+#include <linux/device.h>
+
+/*
+ * Copy from dev_name(). Someone like to use "dev_name" as local variable,
+ * which will case compile error.
+ */
+static inline const char *sunxi_log_dev_name(const struct device *dev)
+{
+	/* Use the init name until the kobject becomes available */
+	if (dev->init_name)
+		return dev->init_name;
+
+	return kobject_name(&dev->kobj);
+}
+
+/*
+ * Parameter Description:
+ * 1. dev: Optional parameter. If the context cannot obtain dev, fill in NULL
+ * 2. fmt: Format specifier
+ * 3. err_code: Error code. Only used in sunxi_err_std()
+ * 4. ...: Variable arguments
+ */
+
+#if IS_ENABLED(CONFIG_AW_LOG_VERBOSE)
+
+/* void sunxi_err(struct device *dev, char *fmt, ...); */
+#define sunxi_err(dev, fmt, ...)											\
+	do { if (dev)													\
+		pr_err("-%s:[ERR]:%s +%d %s(): "fmt, sunxi_log_dev_name(dev), __FILE__, __LINE__, __func__, ## __VA_ARGS__);	\
+	     else													\
+		pr_err(":[ERR]:%s +%d %s(): "fmt, __FILE__, __LINE__, __func__, ## __VA_ARGS__);				\
+	} while (0)
+
+/* void sunxi_err_std(struct device *dev, int err_code, char *fmt, ...); */
+#define sunxi_err_std(dev, err_code, fmt, ...)											\
+	do { if (dev)														\
+		pr_err("-%s:[ERR%d]:%s +%d %s(): "fmt, sunxi_log_dev_name(dev), err_code, __FILE__, __LINE__, __func__, ## __VA_ARGS__);	\
+	     else														\
+		pr_err(":[ERR%d]:%s +%d %s(): "fmt, err_code, __FILE__, __LINE__, __func__, ## __VA_ARGS__);			\
+	} while (0)
+
+/* void sunxi_warn(struct device *dev, char *fmt, ...); */
+#define sunxi_warn(dev, fmt, ...)											\
+	do { if (dev)													\
+		pr_warn("-%s:[WARN]:%s +%d %s(): "fmt, sunxi_log_dev_name(dev), __FILE__, __LINE__, __func__, ## __VA_ARGS__);	\
+	     else													\
+		pr_warn(":[WARN]:%s +%d %s(): "fmt, __FILE__, __LINE__, __func__, ## __VA_ARGS__);			\
+	} while (0)
+
+/* void sunxi_info(struct device *dev, char *fmt, ...); */
+#define sunxi_info(dev, fmt, ...)											\
+	do { if (dev)													\
+		pr_info("-%s:[INFO]:%s +%d %s(): "fmt, sunxi_log_dev_name(dev), __FILE__, __LINE__, __func__, ## __VA_ARGS__);	\
+	     else													\
+		pr_info(":[INFO]:%s +%d %s(): "fmt, __FILE__, __LINE__, __func__, ## __VA_ARGS__);			\
+	} while (0)
+
+/* void sunxi_debug(struct device *dev, char *fmt, ...); */
+#define sunxi_debug(dev, fmt, ...)											\
+	do { if (dev)													\
+		pr_debug("-%s:[DEBUG]:%s +%d %s(): "fmt, sunxi_log_dev_name(dev), __FILE__, __LINE__, __func__, ## __VA_ARGS__);	\
+	     else													\
+		pr_debug(":[DEBUG]:%s +%d %s(): "fmt, __FILE__, __LINE__, __func__, ## __VA_ARGS__);			\
+	} while (0)
+
+#else  /* !CONFIG_AW_LOG_VERBOSE */
+
+/* void sunxi_err(struct device *dev, char *fmt, ...); */
+#define sunxi_err(dev, fmt, ...)							\
+	do { if (dev)									\
+		pr_err("-%s:[ERR]: "fmt, sunxi_log_dev_name(dev), ## __VA_ARGS__);			\
+	     else									\
+		pr_err(":[ERR]: "fmt, ## __VA_ARGS__);					\
+	} while (0)
+
+/* void sunxi_err_std(struct device *dev, int err_code, char *fmt, ...); */
+#define sunxi_err_std(dev, err_code, fmt, ...)						\
+	do { if (dev)									\
+		pr_err("-%s:[ERR%d]: "fmt, sunxi_log_dev_name(dev), err_code, ## __VA_ARGS__);	\
+	     else									\
+		pr_err(":[ERR%d]: "fmt, err_code, ## __VA_ARGS__);			\
+	} while (0)
+
+/* void sunxi_warn(struct device *dev, char *fmt, ...); */
+#define sunxi_warn(dev, fmt, ...)							\
+	do { if (dev)									\
+		pr_warn("-%s:[WARN]: "fmt, sunxi_log_dev_name(dev), ## __VA_ARGS__);		\
+	     else									\
+		pr_warn(":[WARN]: "fmt, ## __VA_ARGS__);					\
+	} while (0)
+
+/* void sunxi_info(struct device *dev, char *fmt, ...); */
+#define sunxi_info(dev, fmt, ...)						\
+	do { if (dev)								\
+		pr_info("-%s:[INFO]: "fmt, sunxi_log_dev_name(dev), ## __VA_ARGS__);	\
+	     else								\
+		pr_info(":[INFO]: "fmt, ## __VA_ARGS__);				\
+	} while (0)
+
+/* void sunxi_debug(struct device *dev, char *fmt, ...); */
+#define sunxi_debug(dev, fmt, ...)						\
+	do { if (dev)								\
+		pr_debug("-%s:[DEBUG]: "fmt, sunxi_log_dev_name(dev), ## __VA_ARGS__);	\
+	     else								\
+		pr_debug(":[DEBUG]: "fmt, ## __VA_ARGS__);			\
+	} while (0)
+
+#endif  /* CONFIG_AW_LOG_VERBOSE */
+
+/* void sunxi_debug_verbose(struct device *dev, char *fmt, ...); */
+#define sunxi_debug_verbose(dev, fmt, ...)										\
+	do { if (dev)													\
+		pr_debug("-%s:[DEBUG]:%s +%d %s(): "fmt, sunxi_log_dev_name(dev), __FILE__, __LINE__, __func__, ## __VA_ARGS__);	\
+	     else													\
+		pr_debug(":[DEBUG]:%s +%d %s(): "fmt, __FILE__, __LINE__, __func__, ## __VA_ARGS__);			\
+	} while (0)
+
+/* void sunxi_debug_line(struct device *dev); */
+#define sunxi_debug_line(dev)											\
+	do { if (dev)												\
+		pr_debug("-%s:[DEBUG]:%s +%d %s()\n", sunxi_log_dev_name(dev), __FILE__, __LINE__, __func__);		\
+	     else												\
+		pr_debug(":[DEBUG]:%s +%d %s()\n", __FILE__, __LINE__, __func__);				\
+	} while (0)
+
+/*
+ * TODO:
+ * print_hex_dump_debug
+ * print_hex_dump_bytes
+ * trace_printk
+ * printk_ratelimited
+*/
+
+#include "errcode/sunxi-err.h"
+
+#endif
diff --git a/include/sunxi-sid.h b/include/sunxi-sid.h
new file mode 100644
index 000000000000..cc49656087fd
--- /dev/null
+++ b/include/sunxi-sid.h
@@ -0,0 +1,199 @@
+/* SPDX-License-Identifier: GPL-2.0-or-later */
+/* Copyright(c) 2020 - 2023 Allwinner Technology Co.,Ltd. All rights reserved. */
+/*
+ * Copyright(c) 2014-2016 Allwinnertech Co., Ltd.
+ *         http://www.allwinnertech.com
+ *
+ * Author: sunny <sunny@allwinnertech.com>
+ *
+ * allwinner sunxi soc chip version and chip id manager.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+
+#ifndef __SUNXI_SID_H
+#define __SUNXI_SID_H
+
+#include <linux/types.h>
+#include <linux/errno.h>
+
+/* About ChipID of version */
+#define SUNXI_CHIP_REV(p, v)  (p + v)
+
+#define SUNXI_CHIP_SUN8IW6   (0x16730000)
+#define SUN8IW6P1_REV_A SUNXI_CHIP_REV(SUNXI_CHIP_SUN8IW6, 0x0000)
+#define SUN8IW6P1_REV_B SUNXI_CHIP_REV(SUNXI_CHIP_SUN8IW6, 0x0001)
+
+#define SUNXI_CHIP_SUN8IW7   (0x16800000)
+#define SUN8IW7P1_REV_A SUNXI_CHIP_REV(SUNXI_CHIP_SUN8IW7, 0x0000)
+#define SUN8IW7P1_REV_B SUNXI_CHIP_REV(SUNXI_CHIP_SUN8IW7, 0x0001)
+#define SUN8IW7P2_REV_A SUNXI_CHIP_REV(SUNXI_CHIP_SUN8IW7, 0x0100)
+#define SUN8IW7P2_REV_B SUNXI_CHIP_REV(SUNXI_CHIP_SUN8IW7, 0x0101)
+
+#define SUNXI_CHIP_SUN8IW8P1 (0x16810000)
+#define SUN8IW8P1_REV_A SUNXI_CHIP_REV(SUNXI_CHIP_SUN8IW8P1, 0x0000)
+#define SUN8IW8P1_REV_B SUNXI_CHIP_REV(SUNXI_CHIP_SUN8IW8P1, 0x0001)
+
+#define SUNXI_CHIP_SUN8IW11   (0x17010000)
+#define SUN8IW11P1_REV_A SUNXI_CHIP_REV(SUNXI_CHIP_SUN8IW11, 0x0000)
+#define SUN8IW11P2_REV_A SUNXI_CHIP_REV(SUNXI_CHIP_SUN8IW11, 0x0001)
+#define SUN8IW11P3_REV_A SUNXI_CHIP_REV(SUNXI_CHIP_SUN8IW11, 0x0011)
+#define SUN8IW11P4_REV_A SUNXI_CHIP_REV(SUNXI_CHIP_SUN8IW11, 0x0101)
+
+#define SUNXI_CHIP_SUN8IW12   (0x17210000)
+#define SUN8IW12P1_REV_A SUNXI_CHIP_REV(SUNXI_CHIP_SUN8IW12, 0x0000)
+
+#define SUNXI_CHIP_SUN8IW15   (0x17550000)
+#define SUN8IW15P1_REV_A SUNXI_CHIP_REV(SUNXI_CHIP_SUN8IW15, 0x0000)
+
+#define SUNXI_CHIP_SUN8IW16   (0x18160000)
+#define SUN8IW16P1_REV_A SUNXI_CHIP_REV(SUNXI_CHIP_SUN8IW16, 0x0000)
+#define SUN8IW16P1_REV_B SUNXI_CHIP_REV(SUNXI_CHIP_SUN8IW16, 0x0001)
+
+#define SUNXI_CHIP_SUN8IW19   (0x18170000)
+#define SUN8IW19P1_REV_A SUNXI_CHIP_REV(SUNXI_CHIP_SUN8IW19, 0x0000)
+
+#define SUNXI_CHIP_SUN8IW21   (0x18860000)
+#define SUN8IW21P1_REV_A SUNXI_CHIP_REV(SUNXI_CHIP_SUN8IW21, 0x0000)
+
+#define SUNXI_CHIP_SUN8IW17   (0x17080000)
+#define SUN8IW17P1_REV_A SUNXI_CHIP_REV(SUNXI_CHIP_SUN8IW17, 0x0000)
+
+#define SUNXI_CHIP_SUN8IW18   (0x18210000)
+#define SUN8IW18P1_REV_A SUNXI_CHIP_REV(SUNXI_CHIP_SUN8IW18, 0x0000)
+
+#define SUNXI_CHIP_SUN50IW1   (0x16890000)
+#define SUN50IW1P1_REV_A	SUNXI_CHIP_REV(SUNXI_CHIP_SUN50IW1, 0x0)
+
+#define SUNXI_CHIP_SUN50IW2   (0x17180000)
+#define SUN50IW2P1_REV_A	SUNXI_CHIP_REV(SUNXI_CHIP_SUN50IW2, 0x0)
+
+#define SUNXI_CHIP_SUN50IW3   (0x17190000)
+#define SUN50IW3P1_REV_A	SUNXI_CHIP_REV(SUNXI_CHIP_SUN50IW3, 0x0)
+
+#define SUNXI_CHIP_SUN50IW6   (0x17280000)
+#define SUN50IW6P1_REV_A	SUNXI_CHIP_REV(SUNXI_CHIP_SUN50IW6, 0x0)
+
+#define SUNXI_CHIP_SUN50IW9   (0x18230000)
+#define SUN50IW9P1_REV_A	SUNXI_CHIP_REV(SUNXI_CHIP_SUN50IW9, 0x0)
+#define SUN50IW9P1_REV_B	SUNXI_CHIP_REV(SUNXI_CHIP_SUN50IW9, 0x1)
+
+#define SUNXI_CHIP_SUN50IW10  (0x18550000)
+#define SUN50IW10P1_REV_A	SUNXI_CHIP_REV(SUNXI_CHIP_SUN50IW10, 0x0)
+
+#define SUNXI_CHIP_SUN50IW11  (0x18510000)
+#define SUN50IW11P1_REV_A	SUNXI_CHIP_REV(SUNXI_CHIP_SUN50IW11, 0x0)
+#define SUN50IW11P1_REV_B	SUNXI_CHIP_REV(SUNXI_CHIP_SUN50IW11, 0x1)
+#define SUN50IW11P1_REV_C	SUNXI_CHIP_REV(SUNXI_CHIP_SUN50IW11, 0x2)
+
+/* The key info in Efuse */
+
+#define EFUSE_CHIPID_NAME	"chipid"
+#define EFUSE_BROM_CONF_NAME	"brom_conf"
+#define EFUSE_BROM_TRY_NAME	"brom_try"
+#define EFUSE_BROM_NAME  	"brom"
+#define EFUSE_TRIM_NAME		"trim"
+#define EFUSE_THM_SENSOR_NAME   "thermal_sensor"
+#define EFUSE_FT_ZONE_NAME	"ft_zone"
+#define EFUSE_RESTRICT_NAME     "restrict"
+#define EFUSE_FTCP_NAME         "ft_cp"
+#define EFUSE_TV_OUT_NAME       "tvout"
+#define EFUSE_TVE_NAME          "tve"
+#define EFUSE_OEM_NAME          "oem"
+#define EFUSE_ANTI_BLUSH_NAME   "anti_blushing"
+
+#define EFUSE_PSENSOR_NAME      "psensor"
+#define EFUSE_DDR_CFG_NAME      "ddr_cfg"
+#define EFUSE_LDOA_NAME         "ldoa"
+#define EFUSE_LDOB_NAME         "ldob"
+#define EFUSE_AUDIO_BIAS_NAME   "audio_bias"
+#define EFUSE_GAMMA_NAME        "gamma"
+#define EFUSE_WR_PROTECT_NAME   "write_protect"
+#define EFUSE_RD_PROTECT_NAME   "read_protect"
+#define EFUSE_IN_NAME           "in"
+#define EFUSE_ID_NAME           "id"
+#define EFUSE_ROTPK_NAME        "rotpk"
+#define EFUSE_SSK_NAME          "ssk"
+#define EFUSE_RSSK_NAME         "rssk"
+#define EFUSE_HDCP_HASH_NAME    "hdcp_hash"
+#define EFUSE_HDCP_PKF_NAME     "hdcp_pkf"
+#define EFUSE_HDCP_DUK_NAME     "hdcp_duk"
+#define EFUSE_EK_HASH_NAME      "ek_hash"
+#define EFUSE_SN_NAME           "sn"
+#define EFUSE_NV1_NAME          "nv1"
+#define EFUSE_NV2_NAME          "nv2"
+#define EFUSE_BACKUP_KEY_NAME   "backup_key"
+#define EFUSE_BACKUP_KEY2_NAME  "backup_key2"
+#define EFUSE_TCON_PARM_NAME    "tcon_parm"
+#define EFUSE_RSAKEY_HASH_NAME  "rsakey_hash"
+#define EFUSE_RENEW_NAME        "renewability"
+#define EFUSE_OPT_ID_NAME       "operator_id"
+#define EFUSE_LIFE_CYCLE_NAME   "life_cycle"
+#define EFUSE_JTAG_SECU_NAME    "jtag_security"
+#define EFUSE_JTAG_ATTR_NAME    "jtag_attr"
+#define EFUSE_CHIP_CONF_NAME    "chip_config"
+#define EFUSE_RESERVED_NAME     "reserved"
+#define EFUSE_RESERVED2_NAME    "reserved2"
+
+#define SUNXI_KEY_NAME_LEN	32
+
+#define SID_PRCTL		0x40
+#define SID_RDKEY		0x60
+#define SID_OP_LOCK		0xAC
+
+#define EFUSE_CHIPID_BASE	"allwinner,sunxi-chipid"
+#define EFUSE_SID_BASE		"allwinner,sunxi-sid"
+#define SRAM_CTRL_BASE		"allwinner,sram_ctrl"
+
+#define EFUSE_MAX_ADDR_SIZE     (256)
+#define EFUSE_RW_MAX_LEN        (64)
+
+typedef struct {
+	char name[64];
+	uint32_t len;
+	uint32_t offset;
+	uint64_t key_data;
+} sunxi_efuse_key_info_t;
+
+#define sunxi_efuse_read(key_name, read_buf) \
+		sunxi_efuse_readn(key_name, read_buf, 1024)
+
+/* The interface functions */
+#if IS_ENABLED(CONFIG_AW_SID)
+unsigned int sunxi_get_soc_ver(void);
+unsigned int sunxi_get_soc_ver_from_reg(void);
+unsigned int sunxi_get_platform_id(void);
+int sunxi_get_soc_chipid(unsigned char *chipid);
+int sunxi_get_soc_chipid_str(char *chipid);
+int sunxi_get_soc_ft_zone_str(char *serial);
+int sunxi_get_soc_rotpk_status_str(char *status);
+int sunxi_get_pmu_chipid(unsigned char *chipid);
+int sunxi_get_serial(unsigned char *serial);
+unsigned int sunxi_get_soc_bin(void);
+int sunxi_soc_is_secure(void);
+s32 sunxi_get_platform(s8 *buf, s32 size);
+s32 sunxi_efuse_readn(s8 *key_name, void *buf, u32 n);
+int sunxi_get_module_param_from_sid(u32 *dst, u32 offset, u32 len);
+unsigned int sunxi_get_soc_markid(void);
+#else
+unsigned int __attribute__((weak)) sunxi_get_soc_ver(void) { return -ENOSYS; }
+unsigned int __attribute__((weak)) sunxi_get_soc_ver_from_reg(void) { return -ENOSYS; }
+unsigned int __attribute__((weak)) sunxi_get_platform_id(void) { return -ENOSYS; }
+int __attribute__((weak)) sunxi_get_soc_chipid(unsigned char *chipid) { return -ENOSYS; }
+int __attribute__((weak)) sunxi_get_soc_chipid_str(char *chipid) { return -ENOSYS; }
+int __attribute__((weak)) sunxi_get_soc_ft_zone_str(char *serial) { return -ENOSYS; }
+int __attribute__((weak)) sunxi_get_soc_rotpk_status_str(char *status) { return -ENOSYS; }
+int __attribute__((weak)) sunxi_get_pmu_chipid(unsigned char *chipid) { return -ENOSYS; }
+int __attribute__((weak)) sunxi_get_serial(unsigned char *serial) { return -ENOSYS; }
+unsigned int __attribute__((weak)) sunxi_get_soc_bin(void) { return -ENOSYS; }
+int __attribute__((weak)) sunxi_soc_is_secure(void) { return -ENOSYS; }
+s32 __attribute__((weak)) sunxi_get_platform(s8 *buf, s32 size) { return -ENOSYS; }
+s32 __attribute__((weak)) sunxi_efuse_readn(s8 *key_name, void *buf, u32 n) { return -ENOSYS; }
+int __attribute__((weak)) sunxi_get_module_param_from_sid(u32 *dst, u32 offset, u32 len) { return -ENOSYS; }
+unsigned int __attribute__((weak)) sunxi_get_soc_markid(void) { return -ENOSYS; }
+#endif
+
+#endif  /* __SUNXI_SID_H */
diff --git a/include/video/drv_hdmi.h b/include/video/drv_hdmi.h
new file mode 100644
index 000000000000..e1798a743828
--- /dev/null
+++ b/include/video/drv_hdmi.h
@@ -0,0 +1,60 @@
+/* SPDX-License-Identifier: GPL-2.0-or-later */
+/* Copyright(c) 2020 - 2023 Allwinner Technology Co.,Ltd. All rights reserved. */
+/*
+ * Allwinner SoCs hdmi driver.
+ *
+ * Copyright (C) 2016 Allwinner.
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2.  This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+
+#ifndef __DRV_HDMI_H__
+#define __DRV_HDMI_H__
+
+typedef struct {
+	__u8    hw_intf;        /* 0:iis  1:spdif 2:pcm */
+	__u16	fs_between;     /* fs */
+	__u32   sample_rate;    /* sample rate */
+	__u8    clk_edge;       /* 0 */
+	__u8    ch0_en;         /* 1 */
+	__u8    ch1_en;         /* 0 */
+	__u8	ch2_en;         /* 0 */
+	__u8	ch3_en;         /* 0 */
+	__u8	word_length;    /* 32 */
+	__u8    shift_ctl;      /* 0 */
+	__u8    dir_ctl;        /* 0 */
+	__u8    ws_pol;
+	__u8    just_pol;
+	__u8    channel_num;
+	__u8	data_raw;
+	__u8    sample_bit;
+	__u8    ca;     /* channel allocation */
+} hdmi_audio_t;
+
+typedef struct {
+	__s32 (*hdmi_audio_enable)(__u8 mode, __u8 channel);
+	__s32 (*hdmi_set_audio_para)(hdmi_audio_t *audio_para);
+	__s32 (*hdmi_is_playback)(void);
+} __audio_hdmi_func;
+
+enum hdmi_hpd_status {
+	STATUE_CLOSE = 0,
+	STATUE_OPEN = 1,
+};
+
+/******************** SND_HDMI for sunxi_v2 begain ***************************/
+#if IS_ENABLED(CONFIG_AW_HDMI_DISP2) || IS_ENABLED(CONFIG_AW_HDMI2_DISP2_SUNXI) || IS_ENABLED(CONFIG_AW_DRM_HDMI20)
+extern int snd_hdmi_get_func(__audio_hdmi_func *hdmi_func);
+#else
+static inline int snd_hdmi_get_func(__audio_hdmi_func *hdmi_func)
+{
+	pr_err("HDMI Audio API is disable\n");
+
+	return -1;
+}
+#endif
+/******************** SND_HDMI for sunxi_v2 end ******************************/
+
+#endif
diff --git a/include/video/sunxi_drm.h b/include/video/sunxi_drm.h
new file mode 100644
index 000000000000..a59dcce017fb
--- /dev/null
+++ b/include/video/sunxi_drm.h
@@ -0,0 +1,376 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * sunxi_drm.h
+ *
+ * Copyright (c) 2007-2024 Allwinnertech Co., Ltd.
+ *
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+#ifndef _SUNXI_DRM_H
+#define _SUNXI_DRM_H
+#include <uapi/drm/drm.h>
+
+#define DCI_REG_COUNT 66
+#define DEBAND_REG_COUNT 22
+#define SHARP_DE35x_COUNT 26
+#define HDR_REG_COUNT 6
+#define SNR_REG_COUNT 11
+#define ASU_REG_COUNT 9
+
+/* -- dci api -- */
+/* dci pqd ioctl para */
+typedef struct _dci_module_param_t {
+	union {
+		int id;
+		/* enum pq_cmd */
+		int cmd;
+	};
+	unsigned int value[DCI_REG_COUNT];
+} dci_module_param_t;
+
+/* dci commit para */
+struct de_dci_commit_para {
+	u32 enable;
+	u32 demo_en;
+};
+
+/* dci blob data */
+struct de_dci_para {
+	struct de_dci_commit_para commit;
+	dci_module_param_t pqd;
+	/* enum pq_dirty_type_mask */
+	u32 dirty;
+};
+
+/* -- dci api end -- */
+
+/* -- deband api -- */
+/* deband pqd ioctl para */
+typedef struct _deband_module_param_t {
+	union {
+		int id;
+		/* enum pq_cmd */
+		int cmd;
+	};
+	unsigned int value[DEBAND_REG_COUNT];
+} deband_module_param_t;
+
+/* deband commit para */
+struct de_deband_commit_para {
+	u32 enable;
+	u32 demo_en;
+};
+
+/* deband blob data */
+struct de_deband_para {
+	struct de_deband_commit_para commit;
+	deband_module_param_t pqd;
+	/* enum pq_dirty_type_mask */
+	u32 dirty;
+};
+
+/* -- deband api end -- */
+
+/* -- sharp api -- */
+/* sharp pqd ioctl para */
+typedef struct _sharp_de35x_t{
+	union {
+		int id;
+		/* enum pq_cmd */
+		int cmd;
+	};
+	unsigned int value[SHARP_DE35x_COUNT];
+} sharp_de35x_t;
+
+/* sharp commit para */
+struct de_sharp_commit_para {
+	u32 enable;
+	u32 demo_en;
+	u32 lti_level;
+	u32 peak_level;
+};
+
+/* sharp blob data */
+struct de_sharp_para {
+	struct de_sharp_commit_para commit;
+	sharp_de35x_t pqd;
+	/* enum pq_dirty_type_mask */
+	u32 dirty;
+};
+
+/* -- sharp api end -- */
+
+/* -- hdr/gtm api -- */
+/* hdr pqd ioctl para */
+typedef struct _hdr_module_param_t {
+	union {
+		int id;
+		/* enum pq_cmd */
+		int cmd;
+	};
+	unsigned int value[HDR_REG_COUNT];
+} hdr_module_param_t;
+
+/* hdr commit para */
+struct de_hdr_commit_para {
+	u32 enable;
+//not support demo mode
+};
+
+/* hdr blob data */
+struct de_hdr_para {
+	struct de_hdr_commit_para commit;
+	hdr_module_param_t pqd;
+	/* enum pq_dirty_type_mask */
+	u32 dirty;
+};
+
+/* -- hdr/gtm api end -- */
+
+/* -- snr api -- */
+/* snr pqd ioctl para */
+typedef struct _snr_module_param_t {
+	union {
+		int id;
+		/* enum pq_cmd */
+		int cmd;
+	};
+	unsigned int value[SNR_REG_COUNT];
+} snr_module_param_t;
+
+enum snr_buffer_flags {
+	DISP_BF_NORMAL     = 0, /* non-stereo */
+	DISP_BF_STEREO_TB  = 1 << 0, /* stereo top-bottom */
+	DISP_BF_STEREO_FP  = 1 << 1, /* stereo frame packing */
+	DISP_BF_STEREO_SSH = 1 << 2, /* stereo side by side half */
+	DISP_BF_STEREO_SSF = 1 << 3, /* stereo side by side full */
+	DISP_BF_STEREO_LI  = 1 << 4, /* stereo line interlace */
+	/*
+	 * 2d plus depth to convert into 3d,
+	 * left and right image using the same frame buffer
+	 */
+	DISP_BF_STEREO_2D_DEPTH  = 1 << 5,
+};
+
+/* snr commit para */
+struct de_snr_commit_para {
+	u32 b_trd_out;
+	unsigned char en;
+	unsigned char demo_en;
+	unsigned char y_strength;
+	unsigned char u_strength;
+	unsigned char v_strength;
+	unsigned char th_ver_line;
+	unsigned char th_hor_line;
+	enum snr_buffer_flags   flags;
+};
+
+/* snr blob data */
+struct de_snr_para {
+	struct de_snr_commit_para commit;
+	snr_module_param_t pqd;
+	/* enum pq_dirty_type_mask */
+	u32 dirty;
+};
+
+/* -- snr api end -- */
+
+/* -- asu api -- */
+/* asu pqd ioctl para */
+typedef struct _asu_module_param_t {
+	union {
+		int id;
+		/* enum pq_cmd */
+		int cmd;
+	};
+	unsigned int value[ASU_REG_COUNT];
+} asu_module_param_t;
+
+/* asu commit para */
+struct de_asu_commit_para {
+	u32 enable;
+	u32 demo_en;
+};
+
+/* asu blob data */
+struct de_asu_para {
+	struct de_asu_commit_para commit;
+	asu_module_param_t pqd;
+	/* enum pq_dirty_type_mask */
+	u32 dirty;
+};
+
+/* -- asu api end -- */
+
+/* --fcm api -- */
+typedef struct fcm_hardware_data {
+	char name[32];
+	u32 lut_id;
+
+	s32 hbh_hue[28];
+	s32 sbh_hue[28];
+	s32 ybh_hue[28];
+
+	s32 angle_hue[28];
+	s32 angle_sat[13];
+	s32 angle_lum[13];
+
+	s32 hbh_sat[364];
+	s32 sbh_sat[364];
+	s32 ybh_sat[364];
+
+	s32 hbh_lum[364];
+	s32 sbh_lum[364];
+	s32 ybh_lum[364];
+} fcm_hardware_data_t;
+
+/* fcm pqd ioctl para */
+struct fcm_info {
+	union {
+		int id;
+		/* enum pq_cmd */
+		int cmd;
+	};
+	fcm_hardware_data_t fcm_data;
+};
+
+/* fcm commit para */
+struct de_fcm_commit_para {
+	u32 enable;
+	u32 demo_en;
+};
+
+/* fcm blob data */
+struct de_fcm_para {
+	struct de_fcm_commit_para commit;
+	struct fcm_info pqd;
+	u32 dirty;
+};
+
+/* --fcm api end -- */
+
+struct de_cdc_para {
+	/* cdc not support disable actually  */
+	u32 enable;
+};
+
+struct de_csc_para {
+	/* csc not support disable actually  */
+	u32 enable;
+};
+
+/* -- gamma api -- */
+/* gamma pqd ioctl para */
+struct gamma_para {
+	union {
+		int id;
+		/* enum pq_cmd */
+		int cmd;
+	};
+	unsigned int size;
+	u32 *lut;
+};
+/* gamma not need commit para, userspace can get/set gamma from libdrm directly */
+
+/* -- gamma api end -- */
+
+/* -- common PQ api -- */
+
+enum pq_cmd {
+	PQ_WRITE_AND_UPDATE = 0,
+	PQ_WRITE_WITHOUT_UPDATE = 1,
+	PQ_READ = 2,
+};
+
+/* ioctl args for pqd */
+/* 0 enum sunxi_pq_type */
+/* 1 hw_id */
+/* 2 ptr: pqd_module para , beginning with int cmd */
+/* 3 bytes of [2] */
+struct ioctl_pq_data {
+	unsigned long data[4];
+};
+
+enum sunxi_pq_type {
+	PQ_SET_REG =		0x1,
+	PQ_GET_REG =		0x2,
+	PQ_ENABLE =		0x3,
+	PQ_COLOR_MATRIX =	0x4,
+	PQ_FCM =		0x5,
+	PQ_CDC =		0x6,
+	PQ_DCI =		0x7,
+	PQ_DEBAND =		0x8,
+	PQ_SHARP35X =		0x9,
+	PQ_SNR =		0xa,
+	PQ_GTM =		0xb,
+	PQ_ASU =		0xc,
+	PQ_GAMMA =		0xd,
+};
+
+enum pq_dirty_mask {
+	FCM_DIRTY =	1 << PQ_FCM,
+	DCI_DIRTY =	1 << PQ_DCI,
+	SHARP_DIRTY =	1 << PQ_SHARP35X,
+	SNR_DIRTY =	1 << PQ_SNR,
+	ASU_DIRTY =	1 << PQ_ASU,
+	DEBAND_DIRTY =	1 << PQ_DEBAND,
+	PQ_ALL_DIRTY =	0xffffffff,
+};
+
+enum pq_dirty_type_mask {
+	PQD_DIRTY_MASK =	1 << 0,
+	COMMIT_DIRTY_MASK =	1 << 1,
+};
+
+struct de_frontend_data {
+	struct de_snr_para snr_para;
+	struct de_dci_para dci_para;
+	struct de_fcm_para fcm_para;
+	struct de_cdc_para cdc_para;
+	struct de_csc_para csc1_para;
+	struct de_csc_para csc2_para;
+	struct de_sharp_para sharp_para;
+	struct de_asu_para asu_para;
+	/* enum pq_dirty_mask */
+	u32 dirty;
+};
+
+struct de_dither_para {
+	u32 enable;
+	u32 dirty;
+};
+
+struct de_smbl_para {
+	u32 enable;
+	u32 dirty;
+};
+
+struct de_fmt_para {
+	u32 enable;
+	u32 dirty;
+};
+
+struct de_backend_data {
+	struct de_dither_para dither_para;
+	struct de_deband_para deband_para;
+	struct de_smbl_para smbl_para;
+	struct de_fmt_para fmt_para;
+	/* enum pq_dirty_mask */
+	u32 dirty;
+};
+
+/* -- common PQ api end -- */
+
+#define DRM_SUNXI_PQ_PROC              0x00
+#define DRM_IOCTL_SUNXI_PQ_PROC        DRM_IOWR(DRM_COMMAND_BASE + DRM_SUNXI_PQ_PROC, struct ioctl_pq_data)
+
+#endif /*End of file*/
diff --git a/include/video/sunxi_metadata.h b/include/video/sunxi_metadata.h
new file mode 100644
index 000000000000..d9934f9b8f14
--- /dev/null
+++ b/include/video/sunxi_metadata.h
@@ -0,0 +1,351 @@
+/* SPDX-License-Identifier: GPL-2.0-or-later */
+/* Copyright(c) 2020 - 2023 Allwinner Technology Co.,Ltd. All rights reserved. */
+/*
+ * Allwinner SoCs display driver.
+ *
+ * Copyright (C) 2016 Allwinner.
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2.  This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+#ifndef __SUNXI_METADATA_H__
+#define __SUNXI_METADATA_H__
+#include <linux/mm.h>
+
+#define NUM_DIV 8
+#define MAX_LUT_SIZE 729
+
+enum {
+	/* hdr static metadata is available */
+	SUNXI_METADATA_FLAG_HDR_SATIC_METADATA   = 0x00000001,
+	/* hdr dynamic metadata is available */
+	SUNXI_METADATA_FLAG_HDR_DYNAMIC_METADATA = 0x00000002,
+	/* hdr10+ metadata */
+	SUNXI_METADATA_FLAG_HDR10P_METADATA      = 0x00000004,
+	/* hdrvivid metadata */
+	SUNXI_METADATA_FLAG_HDRVIVID_HEADER      = 0x00000008,
+	/* afbc header data is available */
+	SUNXI_METADATA_FLAG_AFBC_HEADER          = 0x00000010,
+	/* gralloc set this when allocate buffer */
+	SUNXI_METADATA_FLAG_UNINITIALIZED        = 0xffffffff,
+};
+
+struct afbc_header {
+	u32 signature;
+	u16 filehdr_size;
+	u16 version;
+	u32 body_size;
+	u8 ncomponents;
+	u8 header_layout;
+	u8 yuv_transform;
+	u8 block_split;
+	u8 inputbits[4];
+	u16 block_width;
+	u16 block_height;
+	u16 width;
+	u16 height;
+	u8  left_crop;
+	u8  top_crop;
+	u16 block_layout;
+};
+
+struct display_master_data {
+	/* display primaries */
+	u16 display_primaries_x[3];
+	u16 display_primaries_y[3];
+
+	/* white_point */
+	u16 white_point_x;
+	u16 white_point_y;
+
+	/* max/min display mastering luminance */
+	u32 max_display_mastering_luminance;
+	u32 min_display_mastering_luminance;
+};
+
+/* static metadata type 1 */
+#if IS_ENABLED(CONFIG_AW_DRM)
+struct hdr_static_metadata_fake {
+#else
+struct hdr_static_metadata {
+#endif
+	struct display_master_data disp_master;
+
+	u16 maximum_content_light_level;
+	u16 maximum_frame_average_light_level;
+};
+
+struct hdr_10Plus_metadata {
+	int32_t  targeted_system_display_maximum_luminance;  //ex: 400, (-1: not available)
+	uint16_t application_version; // 0 or 1
+	uint16_t num_distributions; //ex: 9
+	uint32_t maxscl[3]; //0x00000-0x186A0, (display side will divided by 10)
+	uint32_t average_maxrgb; //0x00000-0x186A0, (display side will divided by 10)
+	uint32_t distribution_values[10]; //0x00000-0x186A0(will div by 10)(i=0,1,3-9), 0-100(i=2)
+	uint16_t knee_point_x; //0-4095, (display side will divided by 4095)
+	uint16_t knee_point_y; //0-4095, (display side will divided by 4095)
+	uint16_t num_bezier_curve_anchors; //0-9
+	uint16_t bezier_curve_anchors[9]; //0-1023, (display side will divided by 1023)
+};
+
+/**
+ * Rational number (pair of numerator and denominator).
+ */
+typedef struct AVRational{
+    int num; ///< Numerator
+    int den; ///< Denominator
+} AVRational;
+
+/**
+ * Color tone mapping parameters at a processing window in a dynamic metadata for
+ * CUVA 005.1:2021.
+ */
+typedef struct AVHDRVividColorToneMappingParams {
+    /**
+     * The nominal maximum display luminance of the targeted system display,
+     * in multiples of 1.0/4095 candelas per square metre. The value shall be in
+     * the range of 0.0 to 1.0, inclusive.
+     */
+    AVRational targeted_system_display_maximum_luminance;
+
+    /**
+     * This flag indicates that transfer the base paramter(for value of 1)
+     */
+    int base_enable_flag;
+
+    /**
+     * base_param_m_p in the base parameter,
+     * in multiples of 1.0/16383. The value shall be in
+     * the range of 0.0 to 1.0, inclusive.
+     */
+    AVRational base_param_m_p;
+
+    /**
+     * base_param_m_m in the base parameter,
+     * in multiples of 1.0/10. The value shall be in
+     * the range of 0.0 to 6.3, inclusive.
+     */
+    AVRational base_param_m_m;
+
+    /**
+     * base_param_m_a in the base parameter,
+     * in multiples of 1.0/1023. The value shall be in
+     * the range of 0.0 to 1.0 inclusive.
+     */
+    AVRational base_param_m_a;
+
+    /**
+     * base_param_m_b in the base parameter,
+     * in multiples of 1/1023. The value shall be in
+     * the range of 0.0 to 1.0, inclusive.
+     */
+    AVRational base_param_m_b;
+
+    /**
+     * base_param_m_n in the base parameter,
+     * in multiples of 1.0/10. The value shall be in
+     * the range of 0.0 to 6.3, inclusive.
+     */
+    AVRational base_param_m_n;
+
+    /**
+     * indicates k1_0 in the base parameter,
+     * base_param_k1 <= 1: k1_0 = base_param_k1
+     * base_param_k1 > 1: reserved
+     */
+    int base_param_k1;
+
+    /**
+     * indicates k2_0 in the base parameter,
+     * base_param_k2 <= 1: k2_0 = base_param_k2
+     * base_param_k2 > 1: reserved
+     */
+    int base_param_k2;
+
+    /**
+     * indicates k3_0 in the base parameter,
+     * base_param_k3 == 1: k3_0 = base_param_k3
+     * base_param_k3 == 2: k3_0 = maximum_maxrgb
+     * base_param_k3 > 2: reserved
+     */
+    int base_param_k3;
+
+    /**
+     * This flag indicates that delta mode of base paramter(for value of 1)
+     */
+    int base_param_Delta_enable_mode;
+
+    /**
+     * base_param_Delta in the base parameter,
+     * in multiples of 1.0/127. The value shall be in
+     * the range of 0.0 to 1.0, inclusive.
+     */
+    AVRational base_param_Delta;
+
+    /**
+     * indicates 3Spline_enable_flag in the base parameter,
+     * This flag indicates that transfer three Spline of base paramter(for value of 1)
+     */
+    int three_Spline_enable_flag;
+
+    /**
+     * The number of three Spline. The value shall be in the range
+     * of 1 to 2, inclusive.
+     */
+    int three_Spline_num;
+
+    /**
+     * The mode of three Spline. the value shall be in the range
+     * of 0 to 3, inclusive.
+     */
+    int three_Spline_TH_mode[2];
+
+    /**
+     * three_Spline_TH_enable_MB is in the range of 0.0 to 1.0, inclusive
+     * and in multiples of 1.0/255.
+     *
+     */
+    AVRational three_Spline_TH_enable_MB[2];
+
+    /**
+     * 3Spline_TH_enable of three Spline.
+     * The value shall be in the range of 0.0 to 1.0, inclusive.
+     * and in multiples of 1.0/4095.
+     */
+    AVRational three_Spline_TH_enable[2];
+
+    /**
+     * 3Spline_TH_Delta1 of three Spline.
+     * The value shall be in the range of 0.0 to 0.25, inclusive,
+     * and in multiples of 0.25/1023.
+     */
+    AVRational three_Spline_TH_Delta1[2];
+
+    /**
+     * 3Spline_TH_Delta2 of three Spline.
+     * The value shall be in the range of 0.0 to 0.25, inclusive,
+     * and in multiples of 0.25/1023.
+     */
+    AVRational three_Spline_TH_Delta2[2];
+
+    /**
+     * 3Spline_enable_Strength of three Spline.
+     * The value shall be in the range of 0.0 to 1.0, inclusive,
+     * and in multiples of 1.0/255.
+     */
+    AVRational three_Spline_enable_Strength[2];
+} AVHDRVividColorToneMappingParams;
+
+/**
+ * Color transform parameters at a processing window in a dynamic metadata for
+ * CUVA 005.1:2021.
+ */
+typedef struct AVHDRVividColorTransformParams {
+    /**
+     * Indicates the minimum brightness of the displayed content.
+     * The values should be in the range of 0.0 to 1.0,
+     * inclusive and in multiples of 1/4095.
+     */
+    AVRational minimum_maxrgb;
+
+    /**
+     * Indicates the average brightness of the displayed content.
+     * The values should be in the range of 0.0 to 1.0,
+     * inclusive and in multiples of 1/4095.
+     */
+    AVRational average_maxrgb;
+
+    /**
+     * Indicates the variance brightness of the displayed content.
+     * The values should be in the range of 0.0 to 1.0,
+     * inclusive and in multiples of 1/4095.
+     */
+    AVRational variance_maxrgb;
+
+    /**
+     * Indicates the maximum brightness of the displayed content.
+     * The values should be in the range of 0.0 to 1.0, inclusive
+     * and in multiples of 1/4095.
+     */
+    AVRational maximum_maxrgb;
+
+    /**
+     * This flag indicates that the metadata for the tone mapping function in
+     * the processing window is present (for value of 1).
+     */
+    int tone_mapping_mode_flag;
+
+    /**
+     * The number of tone mapping param. The value shall be in the range
+     * of 1 to 2, inclusive.
+     */
+    int tone_mapping_param_num;
+
+    /**
+     * The color tone mapping parameters.
+     */
+    AVHDRVividColorToneMappingParams tm_params[2];
+
+    /**
+     * This flag indicates that the metadata for the color saturation mapping in
+     * the processing window is present (for value of 1).
+     */
+    int color_saturation_mapping_flag;
+
+    /**
+     * The number of color saturation param. The value shall be in the range
+     * of 0 to 7, inclusive.
+     */
+    int color_saturation_num;
+
+    /**
+     * Indicates the color correction strength parameter.
+     * The values should be in the range of 0.0 to 2.0, inclusive
+     * and in multiples of 1/128.
+     */
+    AVRational color_saturation_gain[8];
+} AVHDRVividColorTransformParams;
+
+typedef struct AVDynamicHDRVivid {
+    int bHdrVividFlag;
+    /**
+     * The system start code. The value shall be set to 0x01.
+     */
+    uint8_t system_start_code;
+
+    /**
+     * The number of processing windows. The value shall be set to 0x01
+     * if the system_start_code is 0x01.
+     */
+    uint8_t num_windows;
+
+    /**
+     * The color transform parameters for every processing window.
+     */
+    AVHDRVividColorTransformParams params[3];
+
+} AVDynamicHDRVivid;
+
+/* hdrvivid dynamic metadata type */
+struct hdrvivid_dynamic_metadata {
+    AVDynamicHDRVivid AvDynamicHdrVivid;
+};
+
+/* sunxi video metadata for ve and de */
+struct sunxi_metadata {
+#if IS_ENABLED(CONFIG_AW_DRM)
+    struct hdr_static_metadata_fake hdr_smetada;
+#else
+    struct hdr_static_metadata hdr_smetada;
+#endif
+    struct afbc_header afbc_head;
+    uint32_t flag;
+
+    struct hdr_10Plus_metadata hdr10_plus_smetada;
+    struct hdrvivid_dynamic_metadata hdrvivid_meta;
+    /*cdc lut for driver*/
+    uint32_t divLut[NUM_DIV][MAX_LUT_SIZE];
+};
+
+#endif /* #ifndef __SUNXI_METADATA_H__ */
-- 
Created with Armbian build tools https://github.com/armbian/build

